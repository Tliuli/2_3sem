*(5Б) Зачем нужны пространства имен. Аддитивность. Вложенность.
Пространство необходимо, когда в одной зоне видимости включаются две библиотеки (.h), имеющие дублирующие друг-друга (с одинаковым объявлением) объекты.

Пространство имен аддитивно. Все объекты с его объявлением присоединяются к нему, т.е. при помощи или оператора разрешения области видимости - ::, или директивы using.

Пространства имен могут быть вложенными. Обычное вложенное пространство имен имеет неквалифицированный доступ к родительским членам, но родительские члены не имеют неквалифицированного доступа к вложенному пространству имен (если оно не объявлено как встроенное).

*(5Б) Единица трансляции это?
Согласно стандарту C++: единица трансляции — это базовая единица компиляции в C++. Он состоит из содержимого одного исходного файла, а также содержимого любых заголовочных файлов, прямо или косвенно включенных в него, за вычетом тех строк, которые были проигнорированы с помощью операторов условной предварительной обработки.

Одну единицу перевода можно скомпилировать в объектный файл, библиотеку или исполняемую программу.

#т.е. это любой файл, переданный компилятору, после его предварительной обработки.

*(5Б) Что такое линковка(связывание). Когда оно происходит.
Процесс компиляции состоит из следующих шагов: 
1. Препроцессинг
2. Компиляция       | получаем объектный
3. Ассемблирование* | файл .obj
4. Компоновка <- 
5. Загрузка

После того, как компилятор создал один или несколько объектных файлов, включается другая программа — компоновщик или линкер. Работа компоновщика состоит из трех частей:

а) Берет все объектные файлы, сгенерированные компилятором, и объединяет их в единую исполняемую программу

б) Помимо возможности связывать объектные файлы компоновщик также может связывать файлы библиотек. Файл библиотеки — это набор предварительно скомпилированного кода, который был упакован для повторного использования в других программах

в) Обеспечивает правильное разрешение всех межфайловых зависимостей. Например, если мы определяем что-то в одном файле .cpp, а затем используем это в другом файле .cpp, компоновщик соединит их вместе. Если компоновщик не может связать ссылку с чем-то с ее определением, мы получим ошибку компоновщика, и процесс линковки прервется

*(10Б) Предназначение .h (.hpp) файлов. Куда какие хедеры следует подключать.

Каждое имя должно быть объявлено (прямо или косвенно) в каждом CPP-файле, в котором оно используется. При компиляции программы каждый CPP-файл компилируется независимо в единицу трансляции. Компилятор не имеет сведений о том, какие имена объявляются в других единицах компиляции. Это означает, что при определении класса, функции или глобальной переменной необходимо предоставить объявление этой вещи в каждом дополнительном CPP-файле, который ее использует. 

Чтобы свести к минимуму вероятность возникновения ошибок, В C++ принято соглашение об использовании файлов заголовков для хранения объявлений. Вы делаете объявления в файле заголовка, а затем используете директиву #include в каждом CPP-файле или другом файле заголовка, для чего требуется это объявление. Директива #include вставляет копию файла заголовка непосредственно в CPP-файл перед компиляцией.