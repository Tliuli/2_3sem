*(5Б) Из каких сегментов состоит структура памяти процесса?

Глобально память состоит из трех частей. 
1. Разово во время компиляции резервируется определенное кол-во памяти для программы, которое разбивается на две части:
 а) сегмент кода, который предназначен для хранения кода;
 б) сегмент данных, который используется для хранения глобальных переменных.
2. Выделяется память для хранения аргументов и локальных переменных функций при их вызове - стек.
3. Оставшаяся часть памяти компьютера называется динамической и может использоваться для других целей.


*(5Б) Каким образом связаны встроенные указатели и массивы?

#Что такое _встроенные_ указатели?
Массив - это однородная последовательность объектов, расположенных в смежных ячейках памяти; иначе говоря, все элементы массива имеют один и тот же тип и между ними нет промежутков.

Адрес - некоторое число, идентифицирующее ячейку в памяти. Объект, хранящий адрес, называется указателем.

Между массивами и указателями есть сходство. Доступ к элементам массивов осуществляется с помощью оператора индексирования []. Когда этот оператор применяется к указателю, он интерпретирует память как последовательность объектов (имеющих тип, указанный в объявлении указателя), на первый из которых указывает указатель. Имя массива используется для обращения ко всем его элементам и неявно превращается в указатель на его первый элемент(это сделано, например, для того, чтобы избегать передачи большого объема данных по значению), однако оно не является переменной, так что ему ничего нельзя присвоить (и, соответственно, по этой причине, к нему неприменима арифметика указателей). Кроме того, ярким отличием является то, что при использовании с фиксированным массивом sizeof возвращает размер всего массива (длина массива * размер элемента). При использовании с указателем sizeof возвращает размер адреса памяти (в байтах).

#Неявное превращение имени массива является ответственным за то, что нельзя скопировать массивы с помощью оператора присваивания. Требуются чуть более сложные действия.


*(5Б) Почему низкоуровневая работа с памятью не безопасна?

Указатель не знает, на какое кол-во элементов он указывает. Соответственно, компилятор не знает, в каком диапазоне ячеек находятся наши объекты. И можно влезть в ячейки памяти, относящиеся к совершенно другим вещам, но находящихся в памяти рядом с областью работы. Считывая\записывая значение из\в ячейки\у вне допустимого диапазона можно получить совершенно непредсказуемый результат. 


*(5Б) Сколько оперативной памяти может быть адресовано в 16/32/64 битных системах.
[ a - это битность системы. Адресное пространство - это 2^a ячеек памяти, пронумерованных от 0 до 2^a - 1. Однако диапазон возможных адресов, которым могут соответствовать элементы реально существующей памяти, в конкретной платформе всегда ограничен. Это ограниченный диапазон называют размером физического адресного пространства


*(5Б) new, malloc, calloc - отличия.

new обеспечивает доступ к динамической памяти, позволяя там создать объект. Возвращает указатель на тип, для которого выделялась память. Память, выделенная с его помощью, должна быть освобождена через delete. Не поддерживает перераспределение памяти с помощью realloc, только переопределение того же куска памяти заново.
# инструмен C++, более новый и менее подвержен ошибкам. 

- - -
malloc выделяет неинициализированный блок в динамической памяти. Возвращает указатель на выделенную память. В последствии память должна быть освобождена с помощью free.

В отличие от malloc, функция calloc кроме выделения области памяти под массив объектов еще производит инициализацию нулевыми значениями.
# оба инструмента являются наследием C