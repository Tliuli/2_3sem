*(5Б) ключевые слова auto, decltype и статическая типизация.
auto позволяет автоматически определять тип переменной на основе выражения, которое ей присваивается.
decltype позволяет определить тип выражения на основе его значения во время компиляции.
Статическая типизация в C++ означает, что типы переменных определяются на этапе компиляции и не могут изменяться во время выполнения программы. Но из-за этого уменьшаеться "гибкость" программы

*(5Б) Инстанцирование шаблона: что это, как происходит.
Инстанцирование (англ. instance — создание экземпляра чего-то) — процесс порождения специализации. Компилятор или разработчик где-то порождает код через подстановку параметров в шаблон и соответственно, инстанцирование может быть неявным и явным.
Специализация — непосредственное указание частного случая для конкретного типа.

Инстанцирование шаблона может происходить явно или неявно. Явное инстанцирование происходит при явном указании параметров шаблона, например, при вызове функции с указанием типа. Неявное инстанцирование происходит автоматически при использовании шаблона в программе.
Процесс инстанцирования начинается, когда компилятор встречает вызов шаблона с конкретными аргументами. Затем компилятор создает конкретную реализацию шаблона, заменяя все параметры на переданные аргументы. Это может привести к созданию новых типов, функций или переменных, которые могут быть использованы в программе.

*(5Б) Зачем нужны шаблоны с нетиповыми аргументами, приведите примеры.
Шаблоны с нетиповыми аргументами позволяют создавать обобщенный код, который может работать с различными типами данных или значениями, не ограничиваясь только типами данных. 
Примеры использования шаблонов с нетиповыми аргументами:
  1. Шаблон класса std::array из стандартной библиотеки C++ использует нетиповой аргумент для определения размера массива. Например, std::array<int, 5> создает массив из 5 элементов типа int.
  2. Шаблон функции std::max из стандартной библиотеки C++ использует нетиповой аргумент для сравнения значений различных типов данных. Например, std::max(2, 3.5) вернет значение 3.5 типа double.
  3. Шаблон класса std::tuple из стандартной библиотеки C++ использует нетиповые аргументы для создания кортежей различных типов данных. Например, std::tuple<int, double, std::string> создает кортеж из трех элементов типа int, double и std::string.

*(5Б) SFINAE
Аббревиатура SFINAE расшифровывается как substitution failure is not an error и означает следующее: при определении перегрузок функции ошибочные инстанциации шаблонов не вызывают ошибку компиляции, а отбрасываются из списка кандидатов на наиболее подходящую перегрузку. Выражаясь по-человечески, это означает вот что:
а) Когда речь заходит о SFINAE, это обязательно связано с перегрузкой функций.
б) Это работает при автоматическом выводе типов шаблона (type deduction) по аргументам функции.
в) Некоторые перегрузки могут отбрасываться в том случае, когда их невозможно инстанциировать из-за возникающей синтаксической ошибки; компиляция при этом продолжается как ни в чём не бывало, без ошибок.
г)Отбросить могут только шаблон.
д) SFINAE рассматривает только заголовок функции, ошибки в теле функции не будут пропущены.

*(5Б) Универсальные ссылки. std::forward.
«универсальные ссылки» (universal reference) - это rvalue-ссылки, которые в контексте вывода типов.
Функция std::forward, наряду с std::move, предназначена для реализации семантики перемещения в C++. Она принимает forwarding-ссылку, по шаблонному параметру T определяет, передана ей lvalue-ссылка или rvalue-ссылка и возвращает ссылку соответствующего типа. Назначение функции std::forward – это реализация механизма идеальной передачи (perfect forwarding). Этот механизм подразумевает, что объекты, переданные в функцию в виде lvalue-выражений, должны копироваться, а объекты, переданные в функцию в виде rvalue-выражений, должны перемещаться.
